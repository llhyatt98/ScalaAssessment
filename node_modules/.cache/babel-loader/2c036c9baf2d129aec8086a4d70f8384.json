{"ast":null,"code":"// export const fastestTime = (hikers: any, bridges: any) => {\n//     // Sort hikers by speed\n//     hikers.sort((a: any, b: any) => a.speed - b.speed);\n//     let totalTime = 0;\n//     for (let i = 0; i < bridges.length; i++) {\n//         const bridge = bridges[i];\n//         // Check if there are additional hikers on this bridge\n//         let hikersOnBridge = hikers.filter((hiker: any) => bridge.hikers.includes(hiker.id));\n//         if (bridge.additional_hikers) {\n//             hikersOnBridge = hikersOnBridge.concat(hikers.filter((hiker: any) => bridge.additional_hikers.includes(hiker.id)));\n//         }\n//         // Cross the bridge with two slowest hikers at a time\n//         while (hikersOnBridge.length > 0) {\n//             if (hikersOnBridge.length === 1) {\n//                 // Last hiker crosses alone\n//                 totalTime += bridge.length / hikersOnBridge[0].speed;\n//                 hikersOnBridge = [];\n//             } else {\n//                 // Two slowest hikers cross together\n//                 totalTime += Math.max(bridge.length / hikersOnBridge[0].speed, bridge.length / hikersOnBridge[1].speed);\n//                 hikersOnBridge = hikersOnBridge.slice(2);\n//             }\n//         }\n//     }\n//     return totalTime;\n// }\nexport const fastestTime = (hikers, bridges) => {\n  console.log(hikers, bridges); // Sort hikers by speed\n\n  hikers.sort((a, b) => a.speed - b.speed);\n  let totalTime = 0;\n\n  for (let i = 0; i < bridges.length; i++) {\n    const bridge = bridges[i]; // Check if there are additional hikers on this bridge\n\n    let hikersOnBridge = hikers.filter(hiker => bridge.hikers.includes(hiker.id));\n\n    if (bridge.additional_hikers) {\n      hikersOnBridge = hikersOnBridge.concat(hikers.filter(hiker => bridge.additional_hikers.includes(hiker.id)));\n    } // Calculate time for all hikers to cross the bridge\n\n\n    let maxTime = 0;\n\n    for (let j = 0; j < hikersOnBridge.length; j++) {\n      const time = bridge.length / hikersOnBridge[j].speed;\n\n      if (time > maxTime) {\n        maxTime = time;\n      }\n    }\n\n    totalTime += maxTime;\n  }\n\n  return totalTime;\n};","map":{"version":3,"sources":["/Users/llhyatt98/Desktop/Work/ScalaChallenge/src/helpers/fastestPath.ts"],"names":["fastestTime","hikers","bridges","console","log","sort","a","b","speed","totalTime","i","length","bridge","hikersOnBridge","filter","hiker","includes","id","additional_hikers","concat","maxTime","j","time"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA,OAAO,MAAMA,WAAW,GAAG,CAACC,MAAD,EAAcC,OAAd,KAA+B;AACxDC,EAAAA,OAAO,CAACC,GAAR,CAAYH,MAAZ,EAAoBC,OAApB,EADwD,CAExD;;AACAD,EAAAA,MAAM,CAACI,IAAP,CAAY,CAACC,CAAD,EAASC,CAAT,KAAoBD,CAAC,CAACE,KAAF,GAAUD,CAAC,CAACC,KAA5C;AACA,MAAIC,SAAS,GAAG,CAAhB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,OAAO,CAACS,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,UAAME,MAAM,GAAGV,OAAO,CAACQ,CAAD,CAAtB,CADuC,CAEvC;;AACA,QAAIG,cAAc,GAAGZ,MAAM,CAACa,MAAP,CAAeC,KAAD,IAAgBH,MAAM,CAACX,MAAP,CAAce,QAAd,CAAuBD,KAAK,CAACE,EAA7B,CAA9B,CAArB;;AACA,QAAIL,MAAM,CAACM,iBAAX,EAA8B;AAC5BL,MAAAA,cAAc,GAAGA,cAAc,CAACM,MAAf,CAAsBlB,MAAM,CAACa,MAAP,CAAeC,KAAD,IAAgBH,MAAM,CAACM,iBAAP,CAAyBF,QAAzB,CAAkCD,KAAK,CAACE,EAAxC,CAA9B,CAAtB,CAAjB;AACD,KANsC,CAQvC;;;AACA,QAAIG,OAAO,GAAG,CAAd;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,cAAc,CAACF,MAAnC,EAA2CU,CAAC,EAA5C,EAAgD;AAC9C,YAAMC,IAAI,GAAGV,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAACQ,CAAD,CAAd,CAAkBb,KAA/C;;AACA,UAAIc,IAAI,GAAGF,OAAX,EAAoB;AAClBA,QAAAA,OAAO,GAAGE,IAAV;AACD;AACF;;AACDb,IAAAA,SAAS,IAAIW,OAAb;AACD;;AAED,SAAOX,SAAP;AACD,CA1BM","sourcesContent":["// export const fastestTime = (hikers: any, bridges: any) => {\n//     // Sort hikers by speed\n//     hikers.sort((a: any, b: any) => a.speed - b.speed);\n//     let totalTime = 0;\n\n//     for (let i = 0; i < bridges.length; i++) {\n//         const bridge = bridges[i];\n//         // Check if there are additional hikers on this bridge\n//         let hikersOnBridge = hikers.filter((hiker: any) => bridge.hikers.includes(hiker.id));\n//         if (bridge.additional_hikers) {\n//             hikersOnBridge = hikersOnBridge.concat(hikers.filter((hiker: any) => bridge.additional_hikers.includes(hiker.id)));\n//         }\n\n//         // Cross the bridge with two slowest hikers at a time\n//         while (hikersOnBridge.length > 0) {\n//             if (hikersOnBridge.length === 1) {\n//                 // Last hiker crosses alone\n//                 totalTime += bridge.length / hikersOnBridge[0].speed;\n//                 hikersOnBridge = [];\n//             } else {\n//                 // Two slowest hikers cross together\n//                 totalTime += Math.max(bridge.length / hikersOnBridge[0].speed, bridge.length / hikersOnBridge[1].speed);\n//                 hikersOnBridge = hikersOnBridge.slice(2);\n//             }\n//         }\n//     }\n\n//     return totalTime;\n// }\n\nexport const fastestTime = (hikers: any, bridges: any) => {\n  console.log(hikers, bridges);\n  // Sort hikers by speed\n  hikers.sort((a: any, b: any) => a.speed - b.speed);\n  let totalTime = 0;\n\n  for (let i = 0; i < bridges.length; i++) {\n    const bridge = bridges[i];\n    // Check if there are additional hikers on this bridge\n    let hikersOnBridge = hikers.filter((hiker: any) => bridge.hikers.includes(hiker.id));\n    if (bridge.additional_hikers) {\n      hikersOnBridge = hikersOnBridge.concat(hikers.filter((hiker: any) => bridge.additional_hikers.includes(hiker.id)));\n    }\n\n    // Calculate time for all hikers to cross the bridge\n    let maxTime = 0;\n    for (let j = 0; j < hikersOnBridge.length; j++) {\n      const time = bridge.length / hikersOnBridge[j].speed;\n      if (time > maxTime) {\n        maxTime = time;\n      }\n    }\n    totalTime += maxTime;\n  }\n\n  return totalTime;\n}\n"]},"metadata":{},"sourceType":"module"}