{"ast":null,"code":"export const fastestTime = (hikers, bridges) => {\n  // Sort hikers by speed\n  hikers.sort((a, b) => a.speed - b.speed);\n  let totalTime = 0;\n\n  for (let i = 0; i < bridges.length; i++) {\n    const bridge = bridges[i]; // Check if there are additional hikers on this bridge\n\n    let hikersOnBridge = hikers.filter(hiker => bridge.hikers.includes(hiker.id));\n\n    if (bridge.additional_hikers) {\n      hikersOnBridge = hikersOnBridge.concat(hikers.filter(hiker => bridge.additional_hikers.includes(hiker.id)));\n    } // Cross the bridge with two slowest hikers at a time\n\n\n    while (hikersOnBridge.length > 0) {\n      if (hikersOnBridge.length === 1) {\n        // Last hiker crosses alone\n        totalTime += bridge.length / hikersOnBridge[0].speed;\n        hikersOnBridge = [];\n      } else {\n        // Two slowest hikers cross together\n        totalTime += Math.max(bridge.length / hikersOnBridge[0].speed, bridge.length / hikersOnBridge[1].speed);\n        hikersOnBridge = hikersOnBridge.slice(2);\n      }\n    }\n  }\n\n  return totalTime;\n};","map":{"version":3,"sources":["/Users/llhyatt98/Desktop/Work/ScalaChallenge/src/helpers/fastestPath.ts"],"names":["fastestTime","hikers","bridges","sort","a","b","speed","totalTime","i","length","bridge","hikersOnBridge","filter","hiker","includes","id","additional_hikers","concat","Math","max","slice"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,CAACC,MAAD,EAAcC,OAAd,KAA+B;AACtD;AACAD,EAAAA,MAAM,CAACE,IAAP,CAAY,CAACC,CAAD,EAASC,CAAT,KAAoBD,CAAC,CAACE,KAAF,GAAUD,CAAC,CAACC,KAA5C;AACA,MAAIC,SAAS,GAAG,CAAhB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAAO,CAACO,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACrC,UAAME,MAAM,GAAGR,OAAO,CAACM,CAAD,CAAtB,CADqC,CAErC;;AACA,QAAIG,cAAc,GAAGV,MAAM,CAACW,MAAP,CAAeC,KAAD,IAAgBH,MAAM,CAACT,MAAP,CAAca,QAAd,CAAuBD,KAAK,CAACE,EAA7B,CAA9B,CAArB;;AACA,QAAIL,MAAM,CAACM,iBAAX,EAA8B;AAC1BL,MAAAA,cAAc,GAAGA,cAAc,CAACM,MAAf,CAAsBhB,MAAM,CAACW,MAAP,CAAeC,KAAD,IAAgBH,MAAM,CAACM,iBAAP,CAAyBF,QAAzB,CAAkCD,KAAK,CAACE,EAAxC,CAA9B,CAAtB,CAAjB;AACH,KANoC,CAQrC;;;AACA,WAAOJ,cAAc,CAACF,MAAf,GAAwB,CAA/B,EAAkC;AAC9B,UAAIE,cAAc,CAACF,MAAf,KAA0B,CAA9B,EAAiC;AAC7B;AACAF,QAAAA,SAAS,IAAIG,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBL,KAA/C;AACAK,QAAAA,cAAc,GAAG,EAAjB;AACH,OAJD,MAIO;AACH;AACAJ,QAAAA,SAAS,IAAIW,IAAI,CAACC,GAAL,CAAST,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBL,KAA3C,EAAkDI,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBL,KAApF,CAAb;AACAK,QAAAA,cAAc,GAAGA,cAAc,CAACS,KAAf,CAAqB,CAArB,CAAjB;AACH;AACJ;AACJ;;AAED,SAAOb,SAAP;AACH,CA5BM","sourcesContent":["export const fastestTime = (hikers: any, bridges: any) => {\n    // Sort hikers by speed\n    hikers.sort((a: any, b: any) => a.speed - b.speed);\n    let totalTime = 0;\n\n    for (let i = 0; i < bridges.length; i++) {\n        const bridge = bridges[i];\n        // Check if there are additional hikers on this bridge\n        let hikersOnBridge = hikers.filter((hiker: any) => bridge.hikers.includes(hiker.id));\n        if (bridge.additional_hikers) {\n            hikersOnBridge = hikersOnBridge.concat(hikers.filter((hiker: any) => bridge.additional_hikers.includes(hiker.id)));\n        }\n\n        // Cross the bridge with two slowest hikers at a time\n        while (hikersOnBridge.length > 0) {\n            if (hikersOnBridge.length === 1) {\n                // Last hiker crosses alone\n                totalTime += bridge.length / hikersOnBridge[0].speed;\n                hikersOnBridge = [];\n            } else {\n                // Two slowest hikers cross together\n                totalTime += Math.max(bridge.length / hikersOnBridge[0].speed, bridge.length / hikersOnBridge[1].speed);\n                hikersOnBridge = hikersOnBridge.slice(2);\n            }\n        }\n    }\n\n    return totalTime;\n}"]},"metadata":{},"sourceType":"module"}