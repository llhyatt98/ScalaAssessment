{"ast":null,"code":"export const fastestTime = (hikers, bridges) => {\n  console.log(hikers, bridges);\n  let totalTime = 0;\n  let bridgeTimes = [];\n  let hikersAdded = [];\n\n  for (let i = 0; i < bridges.length; i++) {\n    const bridge = bridges[i]; // Check if there are additional hikers on this bridge\n\n    let hikersOnBridge = hikers.filter(hiker => bridge.hikers.includes(hiker.id)); // Add these to our group of hikers\n\n    hikersAdded = hikersAdded.concat(hikersOnBridge);\n    hikersOnBridge = hikersAdded; // Sort hikers by speed\n\n    hikersOnBridge.sort((a, b) => a.speed - b.speed); // Cross the bridge with two slowest hikers at a time\n\n    let bridgeTime = 0;\n\n    while (hikersOnBridge.length > 0) {\n      if (hikersOnBridge.length === 1) {\n        // Last hiker crosses alone\n        bridgeTime += bridge.length / hikersOnBridge[0].speed;\n        hikersOnBridge = [];\n      } else {\n        // Two slowest hikers cross together\n        bridgeTime += Math.max(bridge.length / hikersOnBridge[0].speed, bridge.length / hikersOnBridge[1].speed);\n        hikersOnBridge = hikersOnBridge.slice(2);\n      }\n    }\n\n    totalTime += bridgeTime;\n    bridgeTimes.push(bridgeTime);\n  }\n\n  return {\n    totalTime,\n    bridgeTimes\n  };\n};","map":{"version":3,"sources":["/Users/llhyatt98/Desktop/Work/ScalaChallenge/src/helpers/fastestPath.ts"],"names":["fastestTime","hikers","bridges","console","log","totalTime","bridgeTimes","hikersAdded","i","length","bridge","hikersOnBridge","filter","hiker","includes","id","concat","sort","a","b","speed","bridgeTime","Math","max","slice","push"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,CAACC,MAAD,EAAcC,OAAd,KAA+B;AACtDC,EAAAA,OAAO,CAACC,GAAR,CAAYH,MAAZ,EAAoBC,OAApB;AACA,MAAIG,SAAS,GAAG,CAAhB;AACA,MAAIC,WAAW,GAAG,EAAlB;AAEA,MAAIC,WAAgB,GAAG,EAAvB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAAO,CAACO,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACrC,UAAME,MAAM,GAAGR,OAAO,CAACM,CAAD,CAAtB,CADqC,CAErC;;AACA,QAAIG,cAAc,GAAGV,MAAM,CAACW,MAAP,CAAeC,KAAD,IAC/BH,MAAM,CAACT,MAAP,CAAca,QAAd,CAAuBD,KAAK,CAACE,EAA7B,CADiB,CAArB,CAHqC,CAOrC;;AACAR,IAAAA,WAAW,GAAGA,WAAW,CAACS,MAAZ,CAAmBL,cAAnB,CAAd;AACAA,IAAAA,cAAc,GAAGJ,WAAjB,CATqC,CAWrC;;AACAI,IAAAA,cAAc,CAACM,IAAf,CAAoB,CAACC,CAAD,EAASC,CAAT,KAAoBD,CAAC,CAACE,KAAF,GAAUD,CAAC,CAACC,KAApD,EAZqC,CAcrC;;AACA,QAAIC,UAAU,GAAG,CAAjB;;AACA,WAAOV,cAAc,CAACF,MAAf,GAAwB,CAA/B,EAAkC;AAC9B,UAAIE,cAAc,CAACF,MAAf,KAA0B,CAA9B,EAAiC;AAC7B;AACAY,QAAAA,UAAU,IAAIX,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBS,KAAhD;AACAT,QAAAA,cAAc,GAAG,EAAjB;AACH,OAJD,MAIO;AACH;AACAU,QAAAA,UAAU,IAAIC,IAAI,CAACC,GAAL,CACVb,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBS,KADxB,EAEVV,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBS,KAFxB,CAAd;AAIAT,QAAAA,cAAc,GAAGA,cAAc,CAACa,KAAf,CAAqB,CAArB,CAAjB;AACH;AACJ;;AAEDnB,IAAAA,SAAS,IAAIgB,UAAb;AACAf,IAAAA,WAAW,CAACmB,IAAZ,CAAiBJ,UAAjB;AACH;;AAED,SAAO;AAAEhB,IAAAA,SAAF;AAAaC,IAAAA;AAAb,GAAP;AACD,CA1CI","sourcesContent":["export const fastestTime = (hikers: any, bridges: any) => {\n    console.log(hikers, bridges)\n    let totalTime = 0;\n    let bridgeTimes = [];\n  \n    let hikersAdded: any = []\n    for (let i = 0; i < bridges.length; i++) {\n        const bridge = bridges[i];\n        // Check if there are additional hikers on this bridge\n        let hikersOnBridge = hikers.filter((hiker: any) =>\n            bridge.hikers.includes(hiker.id)\n        );\n    \n        // Add these to our group of hikers\n        hikersAdded = hikersAdded.concat(hikersOnBridge);\n        hikersOnBridge = hikersAdded;\n\n        // Sort hikers by speed\n        hikersOnBridge.sort((a: any, b: any) => a.speed - b.speed);\n\n        // Cross the bridge with two slowest hikers at a time\n        let bridgeTime = 0;\n        while (hikersOnBridge.length > 0) {\n            if (hikersOnBridge.length === 1) {\n                // Last hiker crosses alone\n                bridgeTime += bridge.length / hikersOnBridge[0].speed;\n                hikersOnBridge = [];\n            } else {\n                // Two slowest hikers cross together\n                bridgeTime += Math.max(\n                    bridge.length / hikersOnBridge[0].speed,\n                    bridge.length / hikersOnBridge[1].speed\n                );\n                hikersOnBridge = hikersOnBridge.slice(2);\n            }\n        }\n\n        totalTime += bridgeTime;\n        bridgeTimes.push(bridgeTime);\n    }\n  \n    return { totalTime, bridgeTimes };\n  };\n"]},"metadata":{},"sourceType":"module"}