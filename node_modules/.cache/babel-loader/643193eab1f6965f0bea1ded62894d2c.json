{"ast":null,"code":"export const fastestTime = (hikers, bridges) => {\n  console.log(hikers, bridges); // Sort hikers by speed\n\n  hikers.sort((a, b) => a.speed - b.speed);\n  let totalTime = 0;\n  let bridgeTimes = [];\n\n  for (let i = 0; i < bridges.length; i++) {\n    const bridge = bridges[i]; // Check if there are additional hikers on this bridge\n\n    let hikersOnBridge = hikers.filter(hiker => bridge.hikers.includes(hiker.id));\n\n    if (bridge.additional_hikers) {\n      hikersOnBridge = hikersOnBridge.concat(hikers.filter(hiker => bridge.additional_hikers.includes(hiker.id)));\n    } // Cross the bridge with two slowest hikers at a time\n\n\n    let bridgeTime = 0;\n\n    while (hikersOnBridge.length > 0) {\n      if (hikersOnBridge.length === 1) {\n        // Last hiker crosses alone\n        bridgeTime += bridge.length / hikersOnBridge[0].speed;\n        hikersOnBridge = [];\n      } else {\n        // Two slowest hikers cross together\n        bridgeTime += Math.max(bridge.length / hikersOnBridge[0].speed, bridge.length / hikersOnBridge[1].speed);\n        hikersOnBridge = hikersOnBridge.slice(2);\n      }\n    }\n\n    totalTime += bridgeTime;\n    bridgeTimes.push(bridgeTime);\n  }\n\n  return {\n    totalTime,\n    bridgeTimes\n  };\n};","map":{"version":3,"sources":["/Users/llhyatt98/Desktop/Work/ScalaChallenge/src/helpers/fastestPath.ts"],"names":["fastestTime","hikers","bridges","console","log","sort","a","b","speed","totalTime","bridgeTimes","i","length","bridge","hikersOnBridge","filter","hiker","includes","id","additional_hikers","concat","bridgeTime","Math","max","slice","push"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,CAACC,MAAD,EAAcC,OAAd,KAA+B;AACtDC,EAAAA,OAAO,CAACC,GAAR,CAAYH,MAAZ,EAAoBC,OAApB,EADsD,CAEtD;;AACAD,EAAAA,MAAM,CAACI,IAAP,CAAY,CAACC,CAAD,EAASC,CAAT,KAAoBD,CAAC,CAACE,KAAF,GAAUD,CAAC,CAACC,KAA5C;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,OAAO,CAACU,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,UAAME,MAAM,GAAGX,OAAO,CAACS,CAAD,CAAtB,CADuC,CAEvC;;AACA,QAAIG,cAAc,GAAGb,MAAM,CAACc,MAAP,CAAeC,KAAD,IACjCH,MAAM,CAACZ,MAAP,CAAcgB,QAAd,CAAuBD,KAAK,CAACE,EAA7B,CADmB,CAArB;;AAGA,QAAIL,MAAM,CAACM,iBAAX,EAA8B;AAC5BL,MAAAA,cAAc,GAAGA,cAAc,CAACM,MAAf,CACfnB,MAAM,CAACc,MAAP,CAAeC,KAAD,IACZH,MAAM,CAACM,iBAAP,CAAyBF,QAAzB,CAAkCD,KAAK,CAACE,EAAxC,CADF,CADe,CAAjB;AAKD,KAZsC,CAcvC;;;AACA,QAAIG,UAAU,GAAG,CAAjB;;AACA,WAAOP,cAAc,CAACF,MAAf,GAAwB,CAA/B,EAAkC;AAChC,UAAIE,cAAc,CAACF,MAAf,KAA0B,CAA9B,EAAiC;AAC/B;AACAS,QAAAA,UAAU,IAAIR,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBN,KAAhD;AACAM,QAAAA,cAAc,GAAG,EAAjB;AACD,OAJD,MAIO;AACL;AACAO,QAAAA,UAAU,IAAIC,IAAI,CAACC,GAAL,CACZV,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBN,KADtB,EAEZK,MAAM,CAACD,MAAP,GAAgBE,cAAc,CAAC,CAAD,CAAd,CAAkBN,KAFtB,CAAd;AAIAM,QAAAA,cAAc,GAAGA,cAAc,CAACU,KAAf,CAAqB,CAArB,CAAjB;AACD;AACF;;AACDf,IAAAA,SAAS,IAAIY,UAAb;AACAX,IAAAA,WAAW,CAACe,IAAZ,CAAiBJ,UAAjB;AACD;;AAED,SAAO;AAAEZ,IAAAA,SAAF;AAAaC,IAAAA;AAAb,GAAP;AACD,CA1CI","sourcesContent":["export const fastestTime = (hikers: any, bridges: any) => {\n    console.log(hikers, bridges)\n    // Sort hikers by speed\n    hikers.sort((a: any, b: any) => a.speed - b.speed);\n    let totalTime = 0;\n    let bridgeTimes = [];\n  \n    for (let i = 0; i < bridges.length; i++) {\n      const bridge = bridges[i];\n      // Check if there are additional hikers on this bridge\n      let hikersOnBridge = hikers.filter((hiker: any) =>\n        bridge.hikers.includes(hiker.id)\n      );\n      if (bridge.additional_hikers) {\n        hikersOnBridge = hikersOnBridge.concat(\n          hikers.filter((hiker: any) =>\n            bridge.additional_hikers.includes(hiker.id)\n          )\n        );\n      }\n  \n      // Cross the bridge with two slowest hikers at a time\n      let bridgeTime = 0;\n      while (hikersOnBridge.length > 0) {\n        if (hikersOnBridge.length === 1) {\n          // Last hiker crosses alone\n          bridgeTime += bridge.length / hikersOnBridge[0].speed;\n          hikersOnBridge = [];\n        } else {\n          // Two slowest hikers cross together\n          bridgeTime += Math.max(\n            bridge.length / hikersOnBridge[0].speed,\n            bridge.length / hikersOnBridge[1].speed\n          );\n          hikersOnBridge = hikersOnBridge.slice(2);\n        }\n      }\n      totalTime += bridgeTime;\n      bridgeTimes.push(bridgeTime);\n    }\n  \n    return { totalTime, bridgeTimes };\n  };\n"]},"metadata":{},"sourceType":"module"}